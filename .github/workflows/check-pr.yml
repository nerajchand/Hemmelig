name: Check Pull Request

on:
    pull_request:
        types: [opened, synchronize, reopened, closed]
        branches:
            - main
            - master

jobs:
    check-docker-build:
        name: Build and Test Docker Image
        runs-on: ubuntu-latest
        if: github.event.action != 'closed'
        permissions:
            contents: read
            pull-requests: write
            packages: write

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  ref: ${{ github.head_ref }}

            - name: Fetch base branch
              run: |
                  git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }} || true

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Log in to GitHub Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

            - name: Get PR number and branch name
              id: pr-info
              run: |
                  echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
                  echo "branch_name=$(echo '${{ github.head_ref }}' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)" >> $GITHUB_OUTPUT
                  echo "sha_short=$(echo '${{ github.sha }}' | cut -c1-7)" >> $GITHUB_OUTPUT
                  echo "repo_lower=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

            - name: Get Git diff
              id: git-diff
              run: |
                  # Fetch base branch to ensure we can diff
                  git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }} || true

                  # Generate diff
                  if [ "${{ github.event.pull_request.base.sha }}" != "" ]; then
                    git diff ${{ github.event.pull_request.base.sha }}..${{ github.sha }} > /tmp/pr-diff.txt || echo "Unable to generate diff" > /tmp/pr-diff.txt
                  else
                    git diff origin/${{ github.event.pull_request.base.ref }}..HEAD > /tmp/pr-diff.txt || echo "Unable to generate diff" > /tmp/pr-diff.txt
                  fi

                  # Limit diff size to avoid comment size limits (GitHub has a 65KB limit)
                  DIFF_SIZE=$(wc -c < /tmp/pr-diff.txt | tr -d ' ')
                  if [ "$DIFF_SIZE" -gt 50000 ]; then
                    head -c 50000 /tmp/pr-diff.txt > /tmp/pr-diff-truncated.txt
                    echo "" >> /tmp/pr-diff-truncated.txt
                    echo "... (diff truncated, too large)" >> /tmp/pr-diff-truncated.txt
                    mv /tmp/pr-diff-truncated.txt /tmp/pr-diff.txt
                  fi

            - name: Check if GH_TOKEN is available
              id: check-token
              run: |
                  if [ -n "${{ secrets.GH_TOKEN }}" ]; then
                      echo "has_gh_token=true" >> $GITHUB_OUTPUT
                      echo "‚úÖ GH_TOKEN found, will push image to registry"
                  else
                      echo "has_gh_token=false" >> $GITHUB_OUTPUT
                      echo "‚ö†Ô∏è GH_TOKEN not found, will build and load locally only"
                      echo "üí° To enable pushing images, add GH_TOKEN secret with 'write:packages' permission"
                  fi

            - name: Build Docker image
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  platforms: linux/amd64
                  push: ${{ steps.check-token.outputs.has_gh_token == 'true' }}
                  load: ${{ steps.check-token.outputs.has_gh_token != 'true' }}
                  tags: |
                      ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}
                      ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  build-args: |
                      GIT_SHA=${{ steps.pr-info.outputs.sha_short }}
                      GIT_TAG=pr-${{ steps.pr-info.outputs.pr_number }}

            - name: Test Docker image with docker-compose
              id: test
              run: |
                  IMAGE_TAG="ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}"
                  
                  # If image was pushed, pull it; otherwise use locally loaded image
                  if [ "${{ steps.check-token.outputs.has_gh_token }}" = "true" ]; then
                      echo "Pulling image from registry: $IMAGE_TAG"
                      docker pull $IMAGE_TAG || {
                          echo "‚ö†Ô∏è Failed to pull image, trying locally loaded image..."
                          docker images | grep "${{ steps.pr-info.outputs.repo_lower }}" || exit 1
                      }
                  else
                      echo "Using locally built image: $IMAGE_TAG"
                      # Verify image exists locally (it should have been loaded)
                      if ! docker image inspect $IMAGE_TAG >/dev/null 2>&1; then
                          echo "‚ùå Image not found locally. Build may have failed."
                          exit 1
                      fi
                  fi

                  # Tag the image as hemmelig:latest for docker-compose
                  docker tag $IMAGE_TAG hemmelig:latest
                  echo "‚úÖ Tagged image as hemmelig:latest"

                  # Create test directories
                  mkdir -p ./test-data/hemmelig
                  mkdir -p ./test-database

                  # Create a test docker-compose override file
                  cat > docker-compose.test.yml << 'COMPOSE_EOF'
                  version: '3.8'
                  
                  services:
                      hemmelig:
                          image: hemmelig:latest
                          volumes:
                              - ./test-data/hemmelig:/var/tmp/hemmelig/upload/files
                              - ./test-database:/home/node/hemmelig/database/
                              - ./docker-entrypoint.sh:/home/node/hemmelig/docker-entrypoint.sh
                          environment:
                              - SECRET_LOCAL_HOSTNAME=0.0.0.0
                              - SECRET_PORT=3000
                              - SECRET_HOST=localhost
                              - SECRET_ROOT_USER=groot
                              - SECRET_ROOT_PASSWORD=iamroot
                              - SECRET_ROOT_EMAIL=groot@hemmelig.app
                              - SECRET_FILE_SIZE=4
                              - SECRET_FORCED_LANGUAGE=en
                              - SECRET_JWT_SECRET=test-secret-key
                              - SECRET_MAX_TEXT_SIZE=256
                              - SECRET_ANALYTICS_ENABLED=true
                              - DATABASE_URL=postgresql://hemmelig:hemmelig@postgres:5432/hemmelig
                              - SECRET_MAX_VIEWS_LIMIT=20
                          ports:
                              - '3000:3000'
                          restart: "no"
                          depends_on:
                              postgres:
                                  condition: service_healthy
                      postgres:
                          image: postgres:15
                          restart: "no"
                          environment:
                              POSTGRES_DB: hemmelig
                              POSTGRES_USER: hemmelig
                              POSTGRES_PASSWORD: hemmelig
                          healthcheck:
                              test: ["CMD-SHELL", "pg_isready -U hemmelig"]
                              interval: 2s
                              timeout: 5s
                              retries: 10
                  COMPOSE_EOF
                  # Remove leading spaces from the docker-compose file (heredoc preserves indentation)
                  sed -i 's/^                  //' docker-compose.test.yml

                  echo "‚úÖ Created docker-compose.test.yml"

                  # Start services with docker compose (V2 plugin)
                  echo "Starting services with docker compose..."
                  docker compose -f docker-compose.test.yml up -d

                  # Wait for services to be ready
                  echo "Waiting for services to start..."
                  sleep 15

                  # Check if containers are running
                  if docker compose -f docker-compose.test.yml ps | grep -q "Up"; then
                      echo "‚úÖ Containers are running"
                      
                      # Wait a bit more for migrations and application initialization
                      echo "Waiting for application to initialize (migrations, etc.)..."
                      sleep 10
                      
                      # Test health endpoint
                      HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/healthz || echo "000")
                      if [ "$HEALTH_CHECK" = "200" ]; then
                          echo "‚úÖ Health check passed (HTTP $HEALTH_CHECK)"
                          echo "health_check=passed" >> $GITHUB_OUTPUT
                      else
                          echo "‚ö†Ô∏è Health check returned HTTP $HEALTH_CHECK"
                          echo "health_check=warning" >> $GITHUB_OUTPUT
                          # Show logs for debugging
                          echo "Application logs:"
                          docker compose -f docker-compose.test.yml logs hemmelig || true
                      fi
                      
                      echo "test_status=success" >> $GITHUB_OUTPUT
                  else
                      echo "‚ùå Containers failed to start"
                      echo "All logs:"
                      docker compose -f docker-compose.test.yml logs || true
                      echo "test_status=failed" >> $GITHUB_OUTPUT
                      exit 1
                  fi

                  # Cleanup
                  echo "Cleaning up containers..."
                  docker compose -f docker-compose.test.yml down -v || true
                  rm -f docker-compose.test.yml || true
                  rm -rf ./test-data ./test-database || true

            - name: Generate PR comment
              id: comment
              run: |
                  BUILD_STATUS="‚úÖ"
                  TEST_STATUS="‚úÖ"

                  if [ "${{ steps.test.outputs.test_status }}" != "success" ]; then
                      TEST_STATUS="‚ùå"
                  fi

                  HEALTH_STATUS=""
                  if [ "${{ steps.test.outputs.health_check }}" = "passed" ]; then
                      HEALTH_STATUS="‚úÖ Health check passed"
                  elif [ "${{ steps.test.outputs.health_check }}" = "warning" ]; then
                      HEALTH_STATUS="‚ö†Ô∏è Health check warning"
                  fi

                  IMAGE_TAG="ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}"

                  {
                      echo "## üê≥ Docker Build and Test Results"
                      echo ""
                      echo "### Build Status"
                      echo "$BUILD_STATUS Docker image built successfully"
                      echo ""
                      echo "### Test Status"
                      echo "$TEST_STATUS Container started and tested"
                      if [ -n "$HEALTH_STATUS" ]; then
                          echo "$HEALTH_STATUS"
                      fi
                      echo ""
                      echo "### Test Image"
                      echo ""
                      echo "You can pull and test the image locally:"
                      echo '```bash'
                      echo "docker pull $IMAGE_TAG"
                      echo "docker run -p 3000:3000 $IMAGE_TAG"
                      echo '```'
                      echo ""
                      echo "### Changes in this PR"
                      echo ""
                      echo "<details>"
                      echo "<summary>üìã View diff</summary>"
                      echo ""
                      echo '```diff'
                      cat /tmp/pr-diff.txt
                      echo '```'
                      echo ""
                      echo "</details>"
                  } > /tmp/pr-comment.md

                  # Display comment for debugging
                  cat /tmp/pr-comment.md

            - name: Post PR comment
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const fs = require('fs');
                      const comment = fs.readFileSync('/tmp/pr-comment.md', 'utf8');

                      // Find existing comment from this bot
                      const { data: comments } = await github.rest.issues.listComments({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: context.issue.number,
                      });

                      const botComment = comments.find(comment => 
                          comment.user.type === 'Bot' && 
                          comment.body.includes('üê≥ Docker Build and Test Results')
                      );

                      if (botComment) {
                          // Update existing comment
                          await github.rest.issues.updateComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              comment_id: botComment.id,
                              body: comment
                          });
                      } else {
                          // Create new comment
                          await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: context.issue.number,
                              body: comment
                          });
                      }

            - name: Set job output
              if: steps.test.outputs.test_status != 'success'
              run: |
                  echo "‚ùå Docker build or test failed"
                  exit 1

    cleanup-pr-images:
        name: Cleanup PR Images
        runs-on: ubuntu-latest
        if: github.event.action == 'closed'
        permissions:
            contents: read
            packages: write
        steps:
            - name: Log in to GitHub Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

            - name: Get PR number and repository info
              id: pr-info
              run: |
                  echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
                  echo "repo_lower=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

            - name: Delete PR images
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
                  script: |
                      const repo = context.repo;
                      const prNumber = context.payload.pull_request.number;
                      const repoLower = repo.repo.toLowerCase();
                      const owner = repo.owner;
                      
                      console.log(`üóëÔ∏è Attempting to clean up images for PR #${prNumber}`);
                      console.log(`Repository: ${owner}/${repoLower}`);
                      console.log(`PR tags: pr-${prNumber}, pr-${prNumber}-*`);
                      
                      // Helper function to get package versions (try org first, then user)
                      async function getPackageVersions() {
                          try {
                              // Try organization endpoint first
                              const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  org: owner,
                                  per_page: 100
                              });
                              return { versions, isOrg: true };
                          } catch (orgError) {
                              if (orgError.status === 404) {
                                  // Try user endpoint
                                  try {
                                      const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                                          package_type: 'container',
                                          package_name: repoLower,
                                          username: owner,
                                          per_page: 100
                                      });
                                      return { versions, isOrg: false };
                                  } catch (userError) {
                                      throw userError;
                                  }
                              }
                              throw orgError;
                          }
                      }
                      
                      // Helper function to get detailed version information
                      async function getPackageVersionDetails(versionId, isOrg) {
                          if (isOrg) {
                              return await github.rest.packages.getPackageVersionForOrganization({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  org: owner,
                                  package_version_id: versionId
                              });
                          } else {
                              return await github.rest.packages.getPackageVersionForUser({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  username: owner,
                                  package_version_id: versionId
                              });
                          }
                      }
                      
                      // Helper function to delete a package version
                      async function deletePackageVersion(versionId, isOrg) {
                          if (isOrg) {
                              return await github.rest.packages.deletePackageVersionForOrg({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  org: owner,
                                  package_version_id: versionId
                              });
                          } else {
                              return await github.rest.packages.deletePackageVersionForUser({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  username: owner,
                                  package_version_id: versionId
                              });
                          }
                      }
                      
                      try {
                          // Get all package versions
                          const { versions, isOrg } = await getPackageVersions();
                          
                          console.log(`Found ${versions.length} total package versions`);
                          
                          // Log all versions for debugging
                          console.log('\nüì¶ All package versions:');
                          versions.forEach(v => {
                              const tags = v.metadata?.container?.tags || [];
                              const digest = v.name || v.package_html_url?.split('/').pop() || 'unknown';
                              const url = v.package_html_url || 'N/A';
                              console.log(`  Version ${v.id}: tags=[${tags.length > 0 ? tags.join(', ') : '(untagged)'}], digest=${digest}, url=${url}`);
                          });
                          
                          // Step 1: Find all versions that directly match PR tags
                          const prVersionsByTag = versions.filter(version => {
                              const tags = version.metadata?.container?.tags || [];
                              return tags.some(tag => 
                                  tag === `pr-${prNumber}` || 
                                  tag.startsWith(`pr-${prNumber}-`)
                              );
                          });
                          
                          console.log(`\nüîç Found ${prVersionsByTag.length} versions with PR tags:`);
                          prVersionsByTag.forEach(v => {
                              const tags = v.metadata?.container?.tags || [];
                              console.log(`  ‚úì Version ${v.id}: [${tags.join(', ')}]`);
                          });
                          
                          // Step 2: Get digests from PR-tagged versions
                          // The digest might be in version.name, or we need to get it from the version details
                          const prDigests = new Set();
                          const prVersionIds = new Set();
                          
                          // First, collect all PR-tagged version IDs and get their digests
                          console.log(`\nüîç Fetching detailed information for ${prVersionsByTag.length} PR-tagged versions...`);
                          for (const version of prVersionsByTag) {
                              prVersionIds.add(version.id);
                              try {
                                  const details = await getPackageVersionDetails(version.id, isOrg);
                                  // The digest might be in different places depending on API version
                                  const digest = details.data.name || 
                                                details.data.metadata?.container?.digest ||
                                                details.data.url?.match(/sha256:[a-f0-9]+/)?.[0];
                                  if (digest) {
                                      prDigests.add(digest);
                                      console.log(`  Version ${version.id}: digest=${digest}`);
                                  }
                              } catch (error) {
                                  console.log(`  ‚ö†Ô∏è Could not get details for version ${version.id}: ${error.message}`);
                                  // Fallback: try version.name if available
                                  if (version.name) {
                                      prDigests.add(version.name);
                                  }
                              }
                          }
                          
                          console.log(`\nüîë PR version IDs: [${Array.from(prVersionIds).join(', ')}]`);
                          console.log(`üîë PR digests found: [${Array.from(prDigests).join(', ')}]`);
                          
                          // Step 3: Find all versions that match PR tags OR share the same digest
                          // Also include untagged versions that might be related
                          const allPrVersions = versions.filter(version => {
                              const tags = version.metadata?.container?.tags || [];
                              
                              // Already identified as PR version
                              if (prVersionIds.has(version.id)) {
                                  return true;
                              }
                              
                              // Check if tags match PR pattern
                              const hasPrTag = tags.some(tag => 
                                  tag === `pr-${prNumber}` || 
                                  tag.startsWith(`pr-${prNumber}-`)
                              );
                              
                              if (hasPrTag) {
                                  return true;
                              }
                              
                              // Check if digest matches (for untagged versions)
                              // First try to get detailed version info to find the actual digest
                              if (tags.length === 0 && prDigests.size > 0) {
                                  try {
                                      const details = await getPackageVersionDetails(version.id, isOrg);
                                      const digest = details.data.name || 
                                                    details.data.metadata?.container?.digest ||
                                                    details.data.url?.match(/sha256:[a-f0-9]+/)?.[0];
                                      
                                      if (digest && prDigests.has(digest)) {
                                          console.log(`  ‚Üí Found untagged version ${version.id} with matching digest: ${digest}`);
                                          return true;
                                      }
                                  } catch (error) {
                                      // Fallback: try version.name if available
                                      if (version.name && prDigests.has(version.name)) {
                                          console.log(`  ‚Üí Found untagged version ${version.id} with matching digest (fallback): ${version.name}`);
                                          return true;
                                      }
                                  }
                              } else if (version.name && prDigests.has(version.name)) {
                                  console.log(`  ‚Üí Found untagged version ${version.id} with matching digest: ${version.name}`);
                                  return true;
                              }
                              
                              // Also check if version URL or other identifiers suggest it's a PR version
                              // Some versions might not have tags in metadata but are still PR-related
                              if (version.package_html_url) {
                                  const urlLower = version.package_html_url.toLowerCase();
                                  if (urlLower.includes(`pr-${prNumber}`)) {
                                      console.log(`  ‚Üí Found version ${version.id} with PR in URL: ${version.package_html_url}`);
                                      return true;
                                  }
                              }
                              
                              return false;
                          });
                          
                          // Remove duplicates by version ID
                          const uniquePrVersions = Array.from(
                              new Map(allPrVersions.map(v => [v.id, v])).values()
                          );
                          
                          console.log(`\nüéØ Total unique PR versions to delete: ${uniquePrVersions.length}`);
                          uniquePrVersions.forEach(v => {
                              const tags = v.metadata?.container?.tags || [];
                              const tagStr = tags.length > 0 ? tags.join(', ') : '(untagged)';
                              console.log(`  ‚Üí Version ${v.id}: tags=[${tagStr}]`);
                          });
                          
                          if (uniquePrVersions.length === 0) {
                              console.log('‚ÑπÔ∏è No PR images found to delete');
                              return;
                          }
                          
                          // Delete each matching version
                          let deletedCount = 0;
                          let failedCount = 0;
                          for (const version of uniquePrVersions) {
                              try {
                                  const tags = version.metadata?.container?.tags || [];
                                  const tagStr = tags.length > 0 ? tags.join(', ') : '(untagged)';
                                  console.log(`\nüóëÔ∏è Deleting version ${version.id} with tags: [${tagStr}]`);
                                  
                                  await deletePackageVersion(version.id, isOrg);
                                  
                                  deletedCount++;
                                  console.log(`‚úÖ Successfully deleted version ${version.id}`);
                              } catch (error) {
                                  failedCount++;
                                  console.error(`‚ùå Failed to delete version ${version.id}:`, error.message);
                                  if (error.status === 403) {
                                      console.error(`   This usually means the token lacks 'delete:packages' scope`);
                                  }
                              }
                          }
                          
                          console.log(`\nüìä Summary: Deleted ${deletedCount} of ${uniquePrVersions.length} PR image versions`);
                          if (failedCount > 0) {
                              console.log(`   ‚ö†Ô∏è ${failedCount} deletion(s) failed`);
                          }
                      } catch (error) {
                          if (error.status === 404) {
                              console.log('‚ÑπÔ∏è Package not found or no versions exist');
                          } else if (error.status === 403) {
                              console.log('‚ö†Ô∏è Permission denied. The GH_TOKEN needs the following scopes:');
                              console.log('   - delete:packages');
                              console.log('   - read:packages');
                              console.log('\n   Create a PAT at: https://github.com/settings/tokens');
                              console.log(`   Manual deletion: https://github.com/${owner}/${repo.repo}/pkgs/container/${repoLower}`);
                          } else {
                              console.error('‚ùå Error deleting package versions:', error.message);
                              throw error;
                          }
                      }
