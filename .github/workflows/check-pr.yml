name: Check Pull Request

on:
    pull_request:
        types: [opened, synchronize, reopened, closed]
        branches:
            - main
            - master

jobs:
    check-docker-build:
        name: Build and Test Docker Image
        runs-on: ubuntu-latest
        if: github.event.action != 'closed'
        permissions:
            contents: read
            pull-requests: write
            packages: write

        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  ref: ${{ github.head_ref }}

            - name: Fetch base branch
              run: |
                  git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }} || true

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Log in to GitHub Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

            - name: Get PR number and branch name
              id: pr-info
              run: |
                  echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
                  echo "branch_name=$(echo '${{ github.head_ref }}' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-50)" >> $GITHUB_OUTPUT
                  echo "sha_short=$(echo '${{ github.sha }}' | cut -c1-7)" >> $GITHUB_OUTPUT
                  echo "repo_lower=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

            - name: Get Git diff
              id: git-diff
              run: |
                  # Fetch base branch to ensure we can diff
                  git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }} || true

                  # Generate diff
                  if [ "${{ github.event.pull_request.base.sha }}" != "" ]; then
                    git diff ${{ github.event.pull_request.base.sha }}..${{ github.sha }} > /tmp/pr-diff.txt || echo "Unable to generate diff" > /tmp/pr-diff.txt
                  else
                    git diff origin/${{ github.event.pull_request.base.ref }}..HEAD > /tmp/pr-diff.txt || echo "Unable to generate diff" > /tmp/pr-diff.txt
                  fi

                  # Limit diff size to avoid comment size limits (GitHub has a 65KB limit)
                  DIFF_SIZE=$(wc -c < /tmp/pr-diff.txt | tr -d ' ')
                  if [ "$DIFF_SIZE" -gt 50000 ]; then
                    head -c 50000 /tmp/pr-diff.txt > /tmp/pr-diff-truncated.txt
                    echo "" >> /tmp/pr-diff-truncated.txt
                    echo "... (diff truncated, too large)" >> /tmp/pr-diff-truncated.txt
                    mv /tmp/pr-diff-truncated.txt /tmp/pr-diff.txt
                  fi

            - name: Check if GH_TOKEN is available
              id: check-token
              run: |
                  if [ -n "${{ secrets.GH_TOKEN }}" ]; then
                      echo "has_gh_token=true" >> $GITHUB_OUTPUT
                      echo "‚úÖ GH_TOKEN found, will push image to registry"
                  else
                      echo "has_gh_token=false" >> $GITHUB_OUTPUT
                      echo "‚ö†Ô∏è GH_TOKEN not found, will build and load locally only"
                      echo "üí° To enable pushing images, add GH_TOKEN secret with 'write:packages' permission"
                  fi

            - name: Build Docker image
              id: build
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  platforms: linux/amd64
                  push: ${{ steps.check-token.outputs.has_gh_token == 'true' }}
                  load: ${{ steps.check-token.outputs.has_gh_token != 'true' }}
                  tags: |
                      ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}
                      ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}
                  cache-from: type=gha
                  cache-to: type=gha,mode=max
                  build-args: |
                      GIT_SHA=${{ steps.pr-info.outputs.sha_short }}
                      GIT_TAG=pr-${{ steps.pr-info.outputs.pr_number }}

            - name: Test Docker image with docker-compose
              id: test
              run: |
                  IMAGE_TAG="ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}"
                  
                  # If image was pushed, pull it; otherwise use locally loaded image
                  if [ "${{ steps.check-token.outputs.has_gh_token }}" = "true" ]; then
                      echo "Pulling image from registry: $IMAGE_TAG"
                      docker pull $IMAGE_TAG || {
                          echo "‚ö†Ô∏è Failed to pull image, trying locally loaded image..."
                          docker images | grep "${{ steps.pr-info.outputs.repo_lower }}" || exit 1
                      }
                  else
                      echo "Using locally built image: $IMAGE_TAG"
                      # Verify image exists locally (it should have been loaded)
                      if ! docker image inspect $IMAGE_TAG >/dev/null 2>&1; then
                          echo "‚ùå Image not found locally. Build may have failed."
                          exit 1
                      fi
                  fi

                  # Tag the image as hemmelig:latest for docker-compose
                  docker tag $IMAGE_TAG hemmelig:latest
                  echo "‚úÖ Tagged image as hemmelig:latest"

                  # Create test directories
                  mkdir -p ./test-data/hemmelig
                  mkdir -p ./test-database

                  # Create a test docker-compose override file
                  cat > docker-compose.test.yml << 'COMPOSE_EOF'
                  version: '3.8'
                  
                  services:
                      hemmelig:
                          image: hemmelig:latest
                          volumes:
                              - ./test-data/hemmelig:/var/tmp/hemmelig/upload/files
                              - ./test-database:/home/node/hemmelig/database/
                              - ./docker-entrypoint.sh:/home/node/hemmelig/docker-entrypoint.sh
                          environment:
                              - SECRET_LOCAL_HOSTNAME=0.0.0.0
                              - SECRET_PORT=3000
                              - SECRET_HOST=localhost
                              - SECRET_ROOT_USER=groot
                              - SECRET_ROOT_PASSWORD=iamroot
                              - SECRET_ROOT_EMAIL=groot@hemmelig.app
                              - SECRET_FILE_SIZE=4
                              - SECRET_FORCED_LANGUAGE=en
                              - SECRET_JWT_SECRET=test-secret-key
                              - SECRET_MAX_TEXT_SIZE=256
                              - SECRET_ANALYTICS_ENABLED=true
                              - DATABASE_URL=postgresql://hemmelig:hemmelig@postgres:5432/hemmelig
                              - SECRET_MAX_VIEWS_LIMIT=20
                          ports:
                              - '3000:3000'
                          restart: "no"
                          depends_on:
                              postgres:
                                  condition: service_healthy
                      postgres:
                          image: postgres:15
                          restart: "no"
                          environment:
                              POSTGRES_DB: hemmelig
                              POSTGRES_USER: hemmelig
                              POSTGRES_PASSWORD: hemmelig
                          healthcheck:
                              test: ["CMD-SHELL", "pg_isready -U hemmelig"]
                              interval: 2s
                              timeout: 5s
                              retries: 10
                  COMPOSE_EOF
                  # Remove leading spaces from the docker-compose file (heredoc preserves indentation)
                  sed -i 's/^                  //' docker-compose.test.yml

                  echo "‚úÖ Created docker-compose.test.yml"

                  # Start services with docker compose (V2 plugin)
                  echo "Starting services with docker compose..."
                  docker compose -f docker-compose.test.yml up -d

                  # Wait for services to be ready
                  echo "Waiting for services to start..."
                  sleep 15

                  # Check if containers are running
                  if docker compose -f docker-compose.test.yml ps | grep -q "Up"; then
                      echo "‚úÖ Containers are running"
                      
                      # Wait a bit more for migrations and application initialization
                      echo "Waiting for application to initialize (migrations, etc.)..."
                      sleep 10
                      
                      # Test health endpoint
                      HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/healthz || echo "000")
                      if [ "$HEALTH_CHECK" = "200" ]; then
                          echo "‚úÖ Health check passed (HTTP $HEALTH_CHECK)"
                          echo "health_check=passed" >> $GITHUB_OUTPUT
                      else
                          echo "‚ö†Ô∏è Health check returned HTTP $HEALTH_CHECK"
                          echo "health_check=warning" >> $GITHUB_OUTPUT
                          # Show logs for debugging
                          echo "Application logs:"
                          docker compose -f docker-compose.test.yml logs hemmelig || true
                      fi
                      
                      echo "test_status=success" >> $GITHUB_OUTPUT
                  else
                      echo "‚ùå Containers failed to start"
                      echo "All logs:"
                      docker compose -f docker-compose.test.yml logs || true
                      echo "test_status=failed" >> $GITHUB_OUTPUT
                      exit 1
                  fi

                  # Cleanup
                  echo "Cleaning up containers..."
                  docker compose -f docker-compose.test.yml down -v || true
                  rm -f docker-compose.test.yml || true
                  rm -rf ./test-data ./test-database || true

            - name: Generate PR comment
              id: comment
              run: |
                  BUILD_STATUS="‚úÖ"
                  TEST_STATUS="‚úÖ"

                  if [ "${{ steps.test.outputs.test_status }}" != "success" ]; then
                      TEST_STATUS="‚ùå"
                  fi

                  HEALTH_STATUS=""
                  if [ "${{ steps.test.outputs.health_check }}" = "passed" ]; then
                      HEALTH_STATUS="‚úÖ Health check passed"
                  elif [ "${{ steps.test.outputs.health_check }}" = "warning" ]; then
                      HEALTH_STATUS="‚ö†Ô∏è Health check warning"
                  fi

                  IMAGE_TAG="ghcr.io/${{ steps.pr-info.outputs.repo_lower }}:pr-${{ steps.pr-info.outputs.pr_number }}-${{ steps.pr-info.outputs.sha_short }}"

                  {
                      echo "## üê≥ Docker Build and Test Results"
                      echo ""
                      echo "### Build Status"
                      echo "$BUILD_STATUS Docker image built successfully"
                      echo ""
                      echo "### Test Status"
                      echo "$TEST_STATUS Container started and tested"
                      if [ -n "$HEALTH_STATUS" ]; then
                          echo "$HEALTH_STATUS"
                      fi
                      echo ""
                      echo "### Test Image"
                      echo ""
                      echo "You can pull and test the image locally:"
                      echo '```bash'
                      echo "docker pull $IMAGE_TAG"
                      echo "docker run -p 3000:3000 $IMAGE_TAG"
                      echo '```'
                      echo ""
                      echo "### Changes in this PR"
                      echo ""
                      echo "<details>"
                      echo "<summary>üìã View diff</summary>"
                      echo ""
                      echo '```diff'
                      cat /tmp/pr-diff.txt
                      echo '```'
                      echo ""
                      echo "</details>"
                  } > /tmp/pr-comment.md

                  # Display comment for debugging
                  cat /tmp/pr-comment.md

            - name: Post PR comment
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const fs = require('fs');
                      const comment = fs.readFileSync('/tmp/pr-comment.md', 'utf8');

                      // Find existing comment from this bot
                      const { data: comments } = await github.rest.issues.listComments({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: context.issue.number,
                      });

                      const botComment = comments.find(comment => 
                          comment.user.type === 'Bot' && 
                          comment.body.includes('üê≥ Docker Build and Test Results')
                      );

                      if (botComment) {
                          // Update existing comment
                          await github.rest.issues.updateComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              comment_id: botComment.id,
                              body: comment
                          });
                      } else {
                          // Create new comment
                          await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: context.issue.number,
                              body: comment
                          });
                      }

            - name: Set job output
              if: steps.test.outputs.test_status != 'success'
              run: |
                  echo "‚ùå Docker build or test failed"
                  exit 1

    cleanup-pr-images:
        name: Cleanup PR Images
        runs-on: ubuntu-latest
        if: github.event.action == 'closed'
        permissions:
            contents: read
            packages: write
        steps:
            - name: Log in to GitHub Container Registry
              uses: docker/login-action@v3
              with:
                  registry: ghcr.io
                  username: ${{ github.actor }}
                  password: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

            - name: Get PR number and repository info
              id: pr-info
              run: |
                  echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
                  echo "repo_lower=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

            - name: Delete PR images
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
                  script: |
                      const repo = context.repo;
                      const prNumber = context.payload.pull_request.number;
                      const repoLower = repo.repo.toLowerCase();
                      const owner = repo.owner;
                      
                      console.log(`üóëÔ∏è Attempting to clean up images for PR #${prNumber}`);
                      console.log(`Repository: ${owner}/${repoLower}`);
                      console.log(`PR tags: pr-${prNumber}, pr-${prNumber}-*`);
                      
                      // Helper function to get package versions (try org first, then user)
                      async function getPackageVersions() {
                          try {
                              // Try organization endpoint first
                              const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  org: owner,
                                  per_page: 100
                              });
                              return { versions, isOrg: true };
                          } catch (orgError) {
                              if (orgError.status === 404) {
                                  // Try user endpoint
                                  try {
                                      const { data: versions } = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                                          package_type: 'container',
                                          package_name: repoLower,
                                          username: owner,
                                          per_page: 100
                                      });
                                      return { versions, isOrg: false };
                                  } catch (userError) {
                                      throw userError;
                                  }
                              }
                              throw orgError;
                          }
                      }
                      
                      // Helper function to delete a package version
                      async function deletePackageVersion(versionId, isOrg) {
                          if (isOrg) {
                              return await github.rest.packages.deletePackageVersionForOrg({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  org: owner,
                                  package_version_id: versionId
                              });
                          } else {
                              return await github.rest.packages.deletePackageVersionForUser({
                                  package_type: 'container',
                                  package_name: repoLower,
                                  username: owner,
                                  package_version_id: versionId
                              });
                          }
                      }
                      
                      try {
                          // Get all package versions
                          const { versions, isOrg } = await getPackageVersions();
                          
                          console.log(`Found ${versions.length} package versions`);
                          
                          // Filter versions that match PR tags
                          const prVersions = versions.filter(version => {
                              const tags = version.metadata?.container?.tags || [];
                              return tags.some(tag => 
                                  tag === `pr-${prNumber}` || 
                                  tag.startsWith(`pr-${prNumber}-`)
                              );
                          });
                          
                          console.log(`Found ${prVersions.length} versions matching PR tags`);
                          
                          if (prVersions.length === 0) {
                              console.log('‚ÑπÔ∏è No PR images found to delete');
                              return;
                          }
                          
                          // Delete each matching version
                          let deletedCount = 0;
                          for (const version of prVersions) {
                              try {
                                  const tags = version.metadata?.container?.tags || [];
                                  console.log(`Deleting version ${version.id} with tags: ${tags.join(', ')}`);
                                  
                                  await deletePackageVersion(version.id, isOrg);
                                  
                                  deletedCount++;
                                  console.log(`‚úÖ Deleted version ${version.id}`);
                              } catch (error) {
                                  console.error(`‚ùå Failed to delete version ${version.id}:`, error.message);
                              }
                          }
                          
                          console.log(`\n‚úÖ Successfully deleted ${deletedCount} of ${prVersions.length} PR image versions`);
                      } catch (error) {
                          if (error.status === 404) {
                              console.log('‚ÑπÔ∏è Package not found or no versions exist');
                          } else if (error.status === 403) {
                              console.log('‚ö†Ô∏è Permission denied. Ensure GH_TOKEN has delete:packages permission');
                              console.log('   You may need to manually delete via:');
                              console.log(`   https://github.com/${owner}/${repo.repo}/pkgs/container/${repoLower}`);
                          } else {
                              console.error('‚ùå Error deleting package versions:', error.message);
                              throw error;
                          }
                      }
